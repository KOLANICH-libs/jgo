#!/bin/bash

# A script to execute a main class of a Maven artifact
# which is available locally or from Maven Central.
#
# Works using the maven-dependency-plugin to stash the artifact
# and its deps to a temporary location, then invokes java.
#
# It would be more awesome to enhance the exec-maven-plugin to support
# running something with a classpath built from the local Maven repository
# cache. Then you would get all the features of exec-maven-plugin.
# But this script works in a pinch for simple cases.

# Useful functions.

info() { test $verbose && echo "[INFO] $@"; }
err() { echo "$@" 1>&2; }
die() { err "$@"; exit 1; }

check() {
	for tool in $@
	do
		which "$tool" >/dev/null ||
			die "The '$tool' utility is required but not found"
	done
}

trim() {
	echo "$*" | sed 's/^ *//' | sed 's/ *$//'
}

expand() {
	local expanded="$@"
	for shortcut in "${shortcuts[@]}"
	do
		key=$(trim "${shortcut%=*}")
		val=$(trim "${shortcut#*=}")
		case "$expanded" in
			$key*)
				expanded="$val${expanded#$key}"
				;;
		esac
	done
	echo "$expanded"
}

# Parse configuration file.

configFile="$HOME/.jrunrc"
cacheDir="$HOME/.jrun"
m2Repo="$HOME/.m2/repository"
repositories=()
shortcuts=()

test -f "$configFile" &&
while read line
do
	case "$line" in
		'#'*)
			# skip comment
			;;
		\[*\])
			ltrim="${line:1}"
			section="${ltrim%?}"
			;;
		*=*)
			case "$section" in
				repositories)
					repositories+=("$line")
					;;
				settings)
					key=$(trim "${line%=*}")
					val=$(trim "${line#*=}")
					case "$key" in
						cacheDir) cacheDir="$val";;
						m2Repo) m2Repo="$val";;
					esac
					;;
				shortcuts)
					shortcuts+=("$line")
					;;
				*)
					;;
			esac
			;;
	esac
done <"$configFile"

# Parse arguments.

jvm_args=()
app_args=()
while test $# -gt 0
do
	case "$1" in
	-v)
		test -z "$endpoint" && verbose=1 || app_args+=("$1")
		;;
	-*)
		test -z "$endpoint" && jvm_args+=("$1") || app_args+=("$1")
		;;
	*)
		test -z "$endpoint" && endpoint="$1" || app_args+=("$1")
		;;
	esac
	shift
done

# Parse the endpoint.

endpoint=$(expand "$endpoint")

case "$endpoint" in
	*:*:*:*:*:*) # G:A:V:C:mainClass
		die "Too many elements in endpoint '$endpoint'"
		;;
	*:*:*:*:*) # G:A:V:C:mainClass
		g="${endpoint%%:*}"; remain="${endpoint#*:}"
		a="${remain%%:*}"; remain="${remain#*:}"
		v="${remain%%:*}"; remain="${remain#*:}"
		c="${remain%%:*}"
		mainClass="${remain#*:}"
		;;
	*:*:*:*) # G:A:V:mainClass
		g="${endpoint%%:*}"; remain="${endpoint#*:}"
		a="${remain%%:*}"; remain="${remain#*:}"
		v="${remain%%:*}"
		mainClass="${remain#*:}"
		;;
	*:*:*) # G:A:mainClass or G:A:V
		g="${endpoint%%:*}"; remain="${endpoint#*:}"
		a="${remain%%:*}"; remain="${remain#*:}"
		case "$remain" in
			[0-9]*|RELEASE|LATEST)
				v="$remain"
				;;
			*)
				v="RELEASE"
				mainClass="$remain"
				;;
		esac
		;;
	*:*) # G:A
		g="${endpoint%%:*}"
		a="${endpoint#*:}"
		v="RELEASE"
		;;
	*)
		echo "Usage: jrun [-v] <jvm-args> <endpoint> <main-args>"
		echo
		echo "  -v          : verbose mode flag"
		echo "  <jvm-args>  : any list of arguments to the JVM"
		echo "  <endpoint>  : the artifact and main class to execute"
		echo "  <main-args> : any list of arguments to the main class"
		echo
		echo "The endpoint should have one of the following formats:"
		echo
		echo "- groupId:artifactId"
		echo "- groupId:artifactId:version"
		echo "- groupId:artifactId:mainClass"
		echo "- groupId:artifactId:version:mainClass"
		echo "- groupId:artifactId:version:classifier:mainClass"
		echo
		echo "If version is omitted, then RELEASE is used."
		echo "If mainClass is omitted, it is auto-detected."
		echo "You can also write part of a class beginning with an @ sign,"
		echo "and it will be auto-completed."
		exit 1
		;;
esac
info "Artifact:"
info "- groupId    = $g"
info "- artifactId = $a"
info "- version    = $v"
test "$c" && info "- classifier = $c" || info "- classifier = <none>"

# Create a workspace in the jrun cache directory

check sed mkdir
workspace="$cacheDir/$(echo $endpoint | sed 's/:/\//g' | sed 's/[^0-9a-zA-Z/\.-]/_/g')"
mkdir -p "$workspace"
info "Workspace = $workspace"

if [ -f "$workspace/mainClass" ]
then
	# Workspace is already populated; just use it
	check cat java
	mainClass=$(cat "$workspace/mainClass")
	(
		test $verbose && set -x
		java -cp "$workspace/*" "${jvm_args[@]}" "$mainClass" "${app_args[@]}"
	)
	exit 0
fi

# Synthesize a dummy Maven project.

dep="<groupId>$g</groupId><artifactId>$a</artifactId><version>$v</version>"
test "$c" && dep="$dep<classifier>$c</classifier>"

for repository in "${repositories[@]}"
do
	key=$(trim "${repository%=*}")
	val=$(trim "${repository#*=}")
	repos="$repos<repository><id>$key</id><url>$val</url></repository>"
done

check cat
tmpPOM="$workspace/pom.xml"
cat >"$tmpPOM" <<EOL
<project>
	<modelVersion>4.0.0</modelVersion>
	<groupId>$g-BOOTSTRAPPER</groupId>
	<artifactId>$a-BOOTSTRAPPER</artifactId>
	<version>0</version>
	<dependencies>
		<dependency>$dep</dependency>
	</dependencies>
	<repositories>$repos</repositories>
</project>
EOL

check mvn
buildLog=$(test $verbose && set -x; mvn -f "$tmpPOM" dependency:resolve 2>&1)
if [ $? -ne 0 ]
then
	err "Failed to bootstrap the artifact. Here is the log:"
	err "$buildLog"
	exit 2
fi

# Build a workspace of symlinked artifacts.

check grep sed ln
echo "$buildLog" | grep ':\(compile\|runtime\)' | sed 's/\[INFO\] *//' |
while read gav
do
	case "$gav" in
		*:*:*:*:*:*) # G:A:P:C:V:S
			g="${gav%%:*}"; remain="${gav#*:}"
			a="${remain%%:*}"; remain="${remain#*:}"
			p="${remain%%:*}"; remain="${remain#*:}"
			c="${remain%%:*}"; remain="${remain#*:}"
			v="${remain%%:*}"
			s="${remain#*:}"
			;;
		*:*:*:*:*) # G:A:P:V:S
			g="${gav%%:*}"; remain="${gav#*:}"
			a="${remain%%:*}"; remain="${remain#*:}"
			p="${remain%%:*}"; remain="${remain#*:}"
			c=""
			v="${remain%%:*}"
			s="${remain#*:}"
			;;
	esac
	g=$(echo "$g" | sed 's/\./\//g')
	test "$c" && artName="$a-$v-$c" || artName="$a-$v"
	(
		test $verbose && set -x
		ln -s "$m2Repo/$g/$a/$v/$artName.$p" "$workspace"
	)
done

# Massage the main class as needed.

if [ -z "$mainClass" ]
then
	# Infer the main class from the JAR manifest.
	check unzip grep head sed
	jarPathPrefix="$workspace/$a"
	test "$c" && jarPathPrefix="$jarPathPrefix-$c"
	mainClass=$((test $verbose && set -x;
		unzip -p "$jarPathPrefix"-[0-9]*.jar META-INF/MANIFEST.MF 2>/dev/null) |
		grep Main-Class | head -n1 | sed 's/^Main-Class: *\([a-zA-Z0-9_\.]*\).*/\1/')
	info "Inferred main class: $mainClass"
fi
test "$mainClass" || die "No main class given, and none found."

if [ "z${mainClass:0:1}" = 'z@' ]
then
	# Autocomplete the main class by scanning the JARs.
	check jar grep sed
	mainPath=$(echo "${mainClass:1}" | sed 's/\//./g')
	allClasses="$((test $verbose && set -x;
		for jar in "$workspace/"*.jar; do jar tf "$jar"; done) |
		grep '\.class$' | sed 's/\//./g')"
	completedClass="$(echo "$allClasses" |
		grep "$mainPath\.class$" | head -n1 | sed 's/\.class$//')"
	test "$completedClass" || completedClass="$(echo "$allClasses" |
		grep "$mainPath.*\.class$" | head -n1 | sed 's/\.class$//')"
	test "$completedClass" ||
		die "No autocompletions found for '$mainClass'"
	mainClass="${completedClass}"
	info "Autocompleted main class: $mainClass"
fi
echo "$mainClass" >"$workspace/mainClass"

# Launch it!

check java
(
	test $verbose && set -x
	java -cp "$workspace/*" "${jvm_args[@]}" "$mainClass" "${app_args[@]}"
)
